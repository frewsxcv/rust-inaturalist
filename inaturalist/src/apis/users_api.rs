/*
 * iNaturalist API
 *
 * # https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy
 *
 * The version of the OpenAPI document: 1.3.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`users_autocomplete_get`]
#[derive(Clone, Debug)]
pub struct UsersAutocompleteGetParams {
    /// Search by name (must start with this value) or by ID (exact match).
    pub q: String,
    /// Only show users with memberships to this project
    pub project_id: Option<i32>,
    /// Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
    pub per_page: Option<String>,
}

/// struct for passing parameters to the method [`users_id_get`]
#[derive(Clone, Debug)]
pub struct UsersIdGetParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`users_id_mute_delete`]
#[derive(Clone, Debug)]
pub struct UsersIdMuteDeleteParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`users_id_mute_post`]
#[derive(Clone, Debug)]
pub struct UsersIdMutePostParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`users_id_projects_get`]
#[derive(Clone, Debug)]
pub struct UsersIdProjectsGetParams {
    /// ID of the record
    pub id: i32,
    /// Return more information about project rules, for example return a full taxon object instead of simply an ID
    pub rule_details: Option<String>,
    /// Specify the type of project to return
    pub project_type: Option<String>,
    /// Pagination `page` number
    pub page: Option<String>,
    /// Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
    pub per_page: Option<String>,
}

/// struct for passing parameters to the method [`users_id_put`]
#[derive(Clone, Debug)]
pub struct UsersIdPutParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`users_update_session_put`]
#[derive(Clone, Debug)]
pub struct UsersUpdateSessionPutParams {
    /// Comment object
    pub body: Option<models::PostUserUpdateSession>,
}

/// struct for typed errors of method [`users_autocomplete_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersAutocompleteGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_id_mute_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersIdMuteDeleteError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_id_mute_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersIdMutePostError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_id_projects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersIdProjectsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersMeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_resend_confirmation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersResendConfirmationPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`users_update_session_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUpdateSessionPutError {
    UnknownValue(serde_json::Value),
}

/// Given an string, returns users with names or logins starting with the search term
pub async fn users_autocomplete_get(
    configuration: &configuration::Configuration,
    params: UsersAutocompleteGetParams,
) -> Result<(), Error<UsersAutocompleteGetError>> {
    let uri_str = format!("{}/users/autocomplete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("q", &params.q.to_string())]);
    if let Some(ref param_value) = params.project_id {
        req_builder = req_builder.query(&[("project_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersAutocompleteGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given an ID, returns corresponding user
pub async fn users_id_get(
    configuration: &configuration::Configuration,
    params: UsersIdGetParams,
) -> Result<(), Error<UsersIdGetError>> {
    let uri_str = format!("{}/users/{id}", configuration.base_path, id = params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove a mute on the user specified by {id}
pub async fn users_id_mute_delete(
    configuration: &configuration::Configuration,
    params: UsersIdMuteDeleteParams,
) -> Result<(), Error<UsersIdMuteDeleteError>> {
    let uri_str = format!(
        "{}/users/{id}/mute",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersIdMuteDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Make it so the authenticated user stops receiving notifications about activity by the user specified by {id}.
pub async fn users_id_mute_post(
    configuration: &configuration::Configuration,
    params: UsersIdMutePostParams,
) -> Result<(), Error<UsersIdMutePostError>> {
    let uri_str = format!(
        "{}/users/{id}/mute",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersIdMutePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return projects as user has joined / followed
pub async fn users_id_projects_get(
    configuration: &configuration::Configuration,
    params: UsersIdProjectsGetParams,
) -> Result<(), Error<UsersIdProjectsGetError>> {
    let uri_str = format!(
        "{}/users/{id}/projects",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.rule_details {
        req_builder = req_builder.query(&[("rule_details", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.project_type {
        req_builder = req_builder.query(&[("project_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersIdProjectsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a user
pub async fn users_id_put(
    configuration: &configuration::Configuration,
    params: UsersIdPutParams,
) -> Result<(), Error<UsersIdPutError>> {
    let uri_str = format!("{}/users/{id}", configuration.base_path, id = params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch the logged-in user
pub async fn users_me_get(
    configuration: &configuration::Configuration,
) -> Result<(), Error<UsersMeGetError>> {
    let uri_str = format!("{}/users/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Resend an email confirmation
pub async fn users_resend_confirmation_post(
    configuration: &configuration::Configuration,
) -> Result<(), Error<UsersResendConfirmationPostError>> {
    let uri_str = format!("{}/users/resend_confirmation", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersResendConfirmationPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update the logged-in user's session
pub async fn users_update_session_put(
    configuration: &configuration::Configuration,
    params: UsersUpdateSessionPutParams,
) -> Result<(), Error<UsersUpdateSessionPutError>> {
    let uri_str = format!("{}/users/update_session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UsersUpdateSessionPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
