/*
 * iNaturalist API
 *
 * # https://api.inaturalist.org/v1/  [iNaturalist](https://www.inaturalist.org/) is a global community of naturalists, scientists, and members of the public sharing over a million wildlife sightings to teach one another about the natural world while creating high quality citizen science data for science and conservation.  These API methods return data in JSON/JSONP and PNG response formats. They are meant to supplement the existing [iNaturalist API](https://www.inaturalist.org/pages/api+reference), implemented in Ruby on Rails, which has more functionality and supports more write operations, but tends to be slower and have less consistent response formats. Visit our [developers page](https://www.inaturalist.org/pages/developers) for more information. Write operations that expect and return JSON describe a single `body` parameter that represents the request body, which should be specified as JSON. See the \"Model\" of each body parameter for attributes that we accept in these JSON objects.  Multiple values for a single URL parameter should be separated by commas, e.g. `taxon_id=1,2,3`.  Map tiles are generated using the [node-mapnik](https://github.com/mapnik/node-mapnik) library, following the XYZ map tiling scheme. The \"Observation Tile\" methods accept nearly all the parameters of the observation search APIs, and will generate map tiles reflecting the same observations returned by searches. These \"Observation Tile\" methods have corresponding [UTFGrid](https://github.com/mapbox/utfgrid-spec) JSON responses which return information needed to make interactive maps.  Authentication in the Node API is handled via JSON Web Tokens (JWT). To obtain one, make an [OAuth-authenticated request](http://www.inaturalist.org/pages/api+reference#auth) to https://www.inaturalist.org/users/api_token. Each JWT will expire after 24 hours. Authentication required for all PUT and POST requests. Some GET requests will also include private information like hidden coordinates if the authenticated user has permission to view them.  Photos served from https://static.inaturalist.org and https://inaturalist-open-data.s3.amazonaws.com have multiple size variants and not all size variants are returned in responses. To access other sizes, the photo URL can be modified to replace only the size qualifier (each variant shares the exact same extension). The domain a photo is hosted under reflects the license under which the photo is being shared, and the domain may change over time if the license changes. Photos in the `inaturalist-open-data` domain are shared under open licenses. These can be accessed in bulk in the [iNaturalist AWS Open Dataset]( https://registry.opendata.aws/inaturalist-open-data/). Photos in the `static.inaturalist.org` domain do not have open licenses.  The available photo sizes are: * original (max 2048px in either dimension) * large (max 1024px in either dimension) * medium (max 500px in either dimension) * small (max 240px in either dimension) * thumb (max 100px in either dimension) * square (75px square)  iNaturalist Website: https://www.inaturalist.org/  Open Source Software: https://github.com/inaturalist/  ## Terms of Use  Use of this API is subject to the iNaturalist [Terms of Service](https://www.inaturalist.org/terms) and [Privacy Policy](https://www.inaturalist.org/privacy). We will block any use of our API that violates our Terms or Privacy Policy without notice. The API is intended to support application development, not data scraping. For pre- generated data exports, see https://www.inaturalist.org/pages/developers.  Please note that we throttle API usage to a max of 100 requests per minute, though we ask that you try to keep it to 60 requests per minute or lower, and to keep under 10,000 requests per day. If we notice usage that has serious impact on our performance we may institute blocks without notification.  Terms of Service: https://www.inaturalist.org/terms  Privacy Policy: https://www.inaturalist.org/privacy
 *
 * The version of the OpenAPI document: 1.3.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`observations_deleted_get`]
#[derive(Clone, Debug)]
pub struct ObservationsDeletedGetParams {
    /// Deleted at or after this time
    pub since: String,
}

/// struct for passing parameters to the method [`observations_get`]
#[derive(Clone, Debug)]
pub struct ObservationsGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
    /// Pagination `page` number
    pub page: Option<String>,
    /// Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
    pub per_page: Option<String>,
    /// Sort order
    pub order: Option<String>,
    /// Sort field
    pub order_by: Option<String>,
    /// Return only the record IDs
    pub only_id: Option<bool>,
}

/// struct for passing parameters to the method [`observations_histogram_get`]
#[derive(Clone, Debug)]
pub struct ObservationsHistogramGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
    /// Histogram basis: when the observation was created or observed
    pub date_field: Option<String>,
    /// Time interval for histogram, with groups starting on or contained within the group value. The year, month, week, day, and hour options will set default values for `d1` or `created_d1` depending on the value of `date_field`, to limit the number of groups returned. You can override those values if you want data from a longer or shorter time span. The `hour` interval only works with `date_field=created`, and this you should filter dates with `created_d[1,2]`
    pub interval: Option<String>,
}

/// struct for passing parameters to the method [`observations_id_delete`]
#[derive(Clone, Debug)]
pub struct ObservationsIdDeleteParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_fave_post`]
#[derive(Clone, Debug)]
pub struct ObservationsIdFavePostParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_get`]
#[derive(Clone, Debug)]
pub struct ObservationsIdGetParams {
    /// Must have this ID
    pub id: Vec<i32>,
}

/// struct for passing parameters to the method [`observations_id_put`]
#[derive(Clone, Debug)]
pub struct ObservationsIdPutParams {
    /// ID of the record
    pub id: i32,
    /// Comment object
    pub body: Option<models::PostObservation>,
}

/// struct for passing parameters to the method [`observations_id_quality_metric_delete`]
#[derive(Clone, Debug)]
pub struct ObservationsIdQualityMetricDeleteParams {
    /// ID of the record
    pub id: i32,
    /// Data quality category
    pub metric: String,
}

/// struct for passing parameters to the method [`observations_id_quality_metric_post`]
#[derive(Clone, Debug)]
pub struct ObservationsIdQualityMetricPostParams {
    /// ID of the record
    pub id: i32,
    /// Data quality category
    pub metric: String,
    /// Quality object
    pub body: Option<models::PostQuality>,
}

/// struct for passing parameters to the method [`observations_id_review_delete`]
#[derive(Clone, Debug)]
pub struct ObservationsIdReviewDeleteParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_review_post`]
#[derive(Clone, Debug)]
pub struct ObservationsIdReviewPostParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_subscriptions_get`]
#[derive(Clone, Debug)]
pub struct ObservationsIdSubscriptionsGetParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_taxon_summary_get`]
#[derive(Clone, Debug)]
pub struct ObservationsIdTaxonSummaryGetParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_unfave_delete`]
#[derive(Clone, Debug)]
pub struct ObservationsIdUnfaveDeleteParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_id_viewed_updates_put`]
#[derive(Clone, Debug)]
pub struct ObservationsIdViewedUpdatesPutParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`observations_identifiers_get`]
#[derive(Clone, Debug)]
pub struct ObservationsIdentifiersGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
}

/// struct for passing parameters to the method [`observations_observers_get`]
#[derive(Clone, Debug)]
pub struct ObservationsObserversGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
}

/// struct for passing parameters to the method [`observations_popular_field_values_get`]
#[derive(Clone, Debug)]
pub struct ObservationsPopularFieldValuesGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
}

/// struct for passing parameters to the method [`observations_post`]
#[derive(Clone, Debug)]
pub struct ObservationsPostParams {
    /// Comment object
    pub body: Option<models::PostObservation>,
}

/// struct for passing parameters to the method [`observations_species_counts_get`]
#[derive(Clone, Debug)]
pub struct ObservationsSpeciesCountsGetParams {
    /// Whether or not positional accuracy / coordinate uncertainty has been specified
    pub acc: Option<bool>,
    /// Captive or cultivated observations
    pub captive: Option<bool>,
    /// Observations whose taxa are endemic to their location
    pub endemic: Option<bool>,
    /// Observations that are georeferenced
    pub geo: Option<bool>,
    /// Observations with the deprecated `ID, Please!` flag. Note that this will return observations, but that this attribute is no longer used.
    pub id_please: Option<bool>,
    /// Observations that have community identifications
    pub identified: Option<bool>,
    /// Observations whose taxa are introduced in their location
    pub introduced: Option<bool>,
    /// Observations that show on map tiles
    pub mappable: Option<bool>,
    /// Observations whose taxa are native to their location
    pub native: Option<bool>,
    /// Observations whose taxa are outside their known ranges
    pub out_of_range: Option<bool>,
    /// Observations identified by the curator of a project. If the `project_id` parameter is also specified, this will only consider observations identified by curators of the specified project(s)
    pub pcid: Option<bool>,
    /// Observations with photos
    pub photos: Option<bool>,
    /// Observations that have been favorited by at least one user
    pub popular: Option<bool>,
    /// Observations with sounds
    pub sounds: Option<bool>,
    /// Observations of active taxon concepts
    pub taxon_is_active: Option<bool>,
    /// Observations whose taxa are threatened in their location
    pub threatened: Option<bool>,
    /// Observations with a `quality_grade` of either `needs_id` or `research`. Equivalent to `quality_grade=needs_id,research`
    pub verifiable: Option<bool>,
    /// License attribute of an observation must not be null
    pub licensed: Option<bool>,
    /// License attribute of at least one photo of an observation must not be null
    pub photo_licensed: Option<bool>,
    /// Observation taxon is expected nearby
    pub expected_nearby: Option<bool>,
    /// Must have this ID
    pub id: Option<Vec<String>>,
    /// Must not have this ID
    pub not_id: Option<Vec<String>>,
    /// Observation must have this license
    pub license: Option<Vec<String>>,
    /// Must have an observation field value with this datatype
    pub ofv_datatype: Option<Vec<String>>,
    /// Must have at least one photo with this license
    pub photo_license: Option<Vec<String>>,
    /// Must be observed within the place with this ID
    pub place_id: Option<Vec<i32>>,
    /// Must be added to the project this ID or slug
    pub project_id: Option<Vec<String>>,
    /// Taxon must have this rank
    pub rank: Option<Vec<String>>,
    /// Must be affiliated with the iNaturalist network website with this ID
    pub site_id: Option<Vec<String>>,
    /// Must have at least one sound with this license
    pub sound_license: Option<Vec<String>>,
    /// Only show observations of these taxa and their descendants
    pub taxon_id: Option<Vec<String>>,
    /// Exclude observations of these taxa and their descendants
    pub without_taxon_id: Option<Vec<String>>,
    /// Taxon must have a scientific or common name matching this string
    pub taxon_name: Option<Vec<String>>,
    /// User must have this ID or login
    pub user_id: Option<Vec<String>>,
    /// User must have this login
    pub user_login: Option<Vec<String>>,
    /// Observations identified by a particular user
    pub ident_user_id: Option<i32>,
    /// Must be observed within this hour of the day
    pub hour: Option<Vec<String>>,
    /// Must be observed within this day of the month
    pub day: Option<Vec<String>>,
    /// Must be observed within this month
    pub month: Option<Vec<String>>,
    /// Must be observed within this year
    pub year: Option<Vec<String>>,
    /// Must be created within this day of the month
    pub created_day: Option<Vec<String>>,
    /// Must be created within this month
    pub created_month: Option<Vec<String>>,
    /// Must be created within this year
    pub created_year: Option<Vec<String>>,
    /// Must have an annotation using this controlled term ID
    pub term_id: Option<Vec<i32>>,
    /// Must have an annotation using this controlled value ID. Must be combined with the `term_id` parameter
    pub term_value_id: Option<Vec<i32>>,
    /// Exclude observations with annotations using this controlled value ID.
    pub without_term_id: Option<i32>,
    /// Exclude observations with annotations using this controlled value ID. Must be combined with the `term_id` parameter
    pub without_term_value_id: Option<Vec<i32>>,
    /// Must be combined with the `term_value_id` or the `without_term_value_id` parameter. Must have an annotation using this controlled term ID and associated term value IDs or be missing this annotation.
    pub term_id_or_unknown: Option<Vec<i32>>,
    /// Must have an annotation created by this user
    pub annotation_user_id: Option<Vec<String>>,
    /// Must have a positional accuracy above this value (meters)
    pub acc_above: Option<String>,
    /// Must have a positional accuracy below this value (meters)
    pub acc_below: Option<String>,
    /// Positional accuracy must be below this value (in meters) or be unknown
    pub acc_below_or_unknown: Option<String>,
    /// Must be observed on or after this date
    pub d1: Option<String>,
    /// Must be observed on or before this date
    pub d2: Option<String>,
    /// Must be created at or after this time
    pub created_d1: Option<String>,
    /// Must be created at or before this time
    pub created_d2: Option<String>,
    /// Must be created on this date
    pub created_on: Option<String>,
    /// Must be observed on this date
    pub observed_on: Option<String>,
    /// Must not be of a taxon previously observed by this user
    pub unobserved_by_user_id: Option<i32>,
    /// Must match the rules of the project with this ID or slug
    pub apply_project_rules_for: Option<String>,
    /// Taxon must have this conservation status code. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub cs: Option<String>,
    /// Taxon must have a conservation status from this authority. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csa: Option<String>,
    /// Taxon must have this IUCN conservation status. If the `place_id` parameter is also specified, this will only consider statuses specific to that place
    pub csi: Option<Vec<String>>,
    /// Must have this geoprivacy setting
    pub geoprivacy: Option<Vec<String>>,
    /// Filter observations by the most conservative geoprivacy applied by a conservation status associated with one of the taxa proposed in the current identifications.
    pub taxon_geoprivacy: Option<Vec<String>>,
    /// Must have `geoprivacy` or `taxon_geoprivacy` fields matching these values
    pub obscuration: Option<Vec<String>>,
    /// Taxon must have this rank or lower
    pub hrank: Option<String>,
    /// Taxon must have this rank or higher
    pub lrank: Option<String>,
    /// Taxon must by within this iconic taxon
    pub iconic_taxa: Option<Vec<String>>,
    /// Must have an ID above this value
    pub id_above: Option<String>,
    /// Must have an ID below this value
    pub id_below: Option<String>,
    /// Identifications must meet these criteria
    pub identifications: Option<String>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lat: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub lng: Option<f64>,
    /// Must be within a {`radius`} kilometer circle around this lat/lng (*lat, *lng, radius)
    pub radius: Option<String>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub nelng: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlat: Option<f64>,
    /// Must be within this bounding box (*nelat, *nelng, *swlat, *swlng)
    pub swlng: Option<f64>,
    /// Taxon must be in the list with this ID
    pub list_id: Option<i32>,
    /// Must not be in the project with this ID or slug
    pub not_in_project: Option<String>,
    /// Must not match the rules of the project with this ID or slug
    pub not_matching_project_rules_for: Option<String>,
    /// Must included in this observation accuracy experiment
    pub observation_accuracy_experiment_id: Option<Vec<i32>>,
    /// Search observation properties. Can be combined with `search_on`
    pub q: Option<String>,
    /// Properties to search on, when combined with `q`. Searches across all properties by default
    pub search_on: Option<String>,
    /// Must have this quality grade
    pub quality_grade: Option<String>,
    /// Must be updated since this time
    pub updated_since: Option<String>,
    /// See `reviewed`
    pub viewer_id: Option<String>,
    /// Observations have been reviewed by the user with ID equal to the value of the `viewer_id` parameter
    pub reviewed: Option<bool>,
    /// Locale preference for taxon common names
    pub locale: Option<String>,
    /// Place preference for regional taxon common names
    pub preferred_place_id: Option<i32>,
    /// Set the `Cache-Control` HTTP header with this value as `max-age`, in seconds. This means subsequent identical requests will be cached on iNaturalist servers, and commonly within web browsers
    pub ttl: Option<String>,
    /// Include taxon ancestors in the response
    pub include_ancestors: Option<bool>,
    /// Pagination `page` number
    pub page: Option<String>,
    /// Number of results to return in a `page`. The maximum value is 500
    pub per_page: Option<String>,
}

/// struct for passing parameters to the method [`observations_updates_get`]
#[derive(Clone, Debug)]
pub struct ObservationsUpdatesGetParams {
    /// Must be created at or after this time
    pub created_after: Option<String>,
    /// Notification has been viewed by the user before
    pub viewed: Option<bool>,
    /// Only show updates on observations owned by the currently authenticated user or on observations the authenticated user is following but does not own.
    pub observations_by: Option<String>,
    /// Pagination `page` number
    pub page: Option<String>,
    /// Number of results to return in a `page`. The maximum value is generally 200 unless otherwise noted
    pub per_page: Option<String>,
}

/// struct for passing parameters to the method [`subscriptions_observation_id_subscribe_post`]
#[derive(Clone, Debug)]
pub struct SubscriptionsObservationIdSubscribePostParams {
    /// ID of the record
    pub id: i32,
}

/// struct for passing parameters to the method [`votes_unvote_observation_id_delete`]
#[derive(Clone, Debug)]
pub struct VotesUnvoteObservationIdDeleteParams {
    /// ID of the record
    pub id: i32,
    /// Vote object
    pub body: Option<models::PostObservationVote>,
}

/// struct for passing parameters to the method [`votes_vote_observation_id_post`]
#[derive(Clone, Debug)]
pub struct VotesVoteObservationIdPostParams {
    /// ID of the record
    pub id: i32,
    /// Vote object
    pub body: Option<models::PostObservationVote>,
}

/// struct for typed errors of method [`observations_deleted_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsDeletedGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_histogram_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsHistogramGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_fave_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdFavePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_quality_metric_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdQualityMetricDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_quality_metric_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdQualityMetricPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_review_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdReviewDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_review_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdReviewPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_subscriptions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdSubscriptionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_taxon_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdTaxonSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_unfave_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdUnfaveDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_id_viewed_updates_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdViewedUpdatesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_identifiers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsIdentifiersGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_observers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsObserversGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_popular_field_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsPopularFieldValuesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_species_counts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsSpeciesCountsGetError {
    DefaultResponse(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`observations_updates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObservationsUpdatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`subscriptions_observation_id_subscribe_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubscriptionsObservationIdSubscribePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes_unvote_observation_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesUnvoteObservationIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`votes_vote_observation_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VotesVoteObservationIdPostError {
    UnknownValue(serde_json::Value),
}

/// Given a starting date, return an array of IDs of the authenticated user's observations that have been deleted since that date. Requires authentication
pub async fn observations_deleted_get(
    configuration: &configuration::Configuration,
    params: ObservationsDeletedGetParams,
) -> Result<(), Error<ObservationsDeletedGetError>> {
    let uri_str = format!("{}/observations/deleted", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("since", &params.since.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsDeletedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns observations matching the search criteria. The large size of the observations index prevents us from supporting the `page` parameter when retrieving records from large result sets. If you need to retrieve large numbers of records, use the `per_page` and `id_above` or `id_below` parameters instead.
pub async fn observations_get(
    configuration: &configuration::Configuration,
    params: ObservationsGetParams,
) -> Result<models::ObservationsResponse, Error<ObservationsGetError>> {
    let uri_str = format!("{}/observations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.order_by {
        req_builder = req_builder.query(&[("order_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.only_id {
        req_builder = req_builder.query(&[("only_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObservationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObservationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns histogram data about observations matching the search criteria
pub async fn observations_histogram_get(
    configuration: &configuration::Configuration,
    params: ObservationsHistogramGetParams,
) -> Result<(), Error<ObservationsHistogramGetError>> {
    let uri_str = format!("{}/observations/histogram", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.date_field {
        req_builder = req_builder.query(&[("date_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.interval {
        req_builder = req_builder.query(&[("interval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsHistogramGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete an observation
pub async fn observations_id_delete(
    configuration: &configuration::Configuration,
    params: ObservationsIdDeleteParams,
) -> Result<(), Error<ObservationsIdDeleteError>> {
    let uri_str = format!(
        "{}/observations/{id}",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fave an observation
pub async fn observations_id_fave_post(
    configuration: &configuration::Configuration,
    params: ObservationsIdFavePostParams,
) -> Result<(), Error<ObservationsIdFavePostError>> {
    let uri_str = format!(
        "{}/observations/{id}/fave",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdFavePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given an ID, or an array of IDs in comma-delimited format, returns corresponding observations. A maximum of 200 results will be returned
pub async fn observations_id_get(
    configuration: &configuration::Configuration,
    params: ObservationsIdGetParams,
) -> Result<models::ObservationsShowResponse, Error<ObservationsIdGetError>> {
    let uri_str = format!(
        "{}/observations/{id}",
        configuration.base_path,
        id = params
            .id
            .into_iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(",")
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObservationsShowResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObservationsShowResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update an observation
pub async fn observations_id_put(
    configuration: &configuration::Configuration,
    params: ObservationsIdPutParams,
) -> Result<(), Error<ObservationsIdPutError>> {
    let uri_str = format!(
        "{}/observations/{id}",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a quality metric
pub async fn observations_id_quality_metric_delete(
    configuration: &configuration::Configuration,
    params: ObservationsIdQualityMetricDeleteParams,
) -> Result<(), Error<ObservationsIdQualityMetricDeleteError>> {
    let uri_str = format!(
        "{}/observations/{id}/quality/{metric}",
        configuration.base_path,
        id = params.id,
        metric = crate::apis::urlencode(params.metric)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdQualityMetricDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set the value of a quality metric
pub async fn observations_id_quality_metric_post(
    configuration: &configuration::Configuration,
    params: ObservationsIdQualityMetricPostParams,
) -> Result<(), Error<ObservationsIdQualityMetricPostError>> {
    let uri_str = format!(
        "{}/observations/{id}/quality/{metric}",
        configuration.base_path,
        id = params.id,
        metric = crate::apis::urlencode(params.metric)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdQualityMetricPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unreview an observation
pub async fn observations_id_review_delete(
    configuration: &configuration::Configuration,
    params: ObservationsIdReviewDeleteParams,
) -> Result<(), Error<ObservationsIdReviewDeleteError>> {
    let uri_str = format!(
        "{}/observations/{id}/review",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdReviewDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Review an observation
pub async fn observations_id_review_post(
    configuration: &configuration::Configuration,
    params: ObservationsIdReviewPostParams,
) -> Result<(), Error<ObservationsIdReviewPostError>> {
    let uri_str = format!(
        "{}/observations/{id}/review",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdReviewPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetches any subscriptions the current user has to this observation or the observer
pub async fn observations_id_subscriptions_get(
    configuration: &configuration::Configuration,
    params: ObservationsIdSubscriptionsGetParams,
) -> Result<(), Error<ObservationsIdSubscriptionsGetError>> {
    let uri_str = format!(
        "{}/observations/{id}/subscriptions",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdSubscriptionsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetches information about this observation's taxon, within the context of this observation's location
pub async fn observations_id_taxon_summary_get(
    configuration: &configuration::Configuration,
    params: ObservationsIdTaxonSummaryGetParams,
) -> Result<(), Error<ObservationsIdTaxonSummaryGetError>> {
    let uri_str = format!(
        "{}/observations/{id}/taxon_summary",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdTaxonSummaryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unfave an observation
pub async fn observations_id_unfave_delete(
    configuration: &configuration::Configuration,
    params: ObservationsIdUnfaveDeleteParams,
) -> Result<(), Error<ObservationsIdUnfaveDeleteError>> {
    let uri_str = format!(
        "{}/observations/{id}/unfave",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdUnfaveDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark all updates associated with this observation as viewed by logged-in user
pub async fn observations_id_viewed_updates_put(
    configuration: &configuration::Configuration,
    params: ObservationsIdViewedUpdatesPutParams,
) -> Result<(), Error<ObservationsIdViewedUpdatesPutError>> {
    let uri_str = format!(
        "{}/observations/{id}/viewed_updates",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdViewedUpdatesPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns identifiers of observations matching the search criteria and the count of observations they have identified, ordered by count descending. A maximum of 500 results will be returned
pub async fn observations_identifiers_get(
    configuration: &configuration::Configuration,
    params: ObservationsIdentifiersGetParams,
) -> Result<models::UserCountsResponse, Error<ObservationsIdentifiersGetError>> {
    let uri_str = format!("{}/observations/identifiers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserCountsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserCountsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsIdentifiersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns observers of observations matching the search criteria and the count of observations and distinct taxa of rank `species` they have observed. A maximum of 500 results will be returned
pub async fn observations_observers_get(
    configuration: &configuration::Configuration,
    params: ObservationsObserversGetParams,
) -> Result<models::ObservationsObserversResponse, Error<ObservationsObserversGetError>> {
    let uri_str = format!("{}/observations/observers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ObservationsObserversResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ObservationsObserversResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsObserversGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns an array of relevant controlled terms values and a monthly histogram
pub async fn observations_popular_field_values_get(
    configuration: &configuration::Configuration,
    params: ObservationsPopularFieldValuesGetParams,
) -> Result<(), Error<ObservationsPopularFieldValuesGetError>> {
    let uri_str = format!(
        "{}/observations/popular_field_values",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsPopularFieldValuesGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create an observation
pub async fn observations_post(
    configuration: &configuration::Configuration,
    params: ObservationsPostParams,
) -> Result<(), Error<ObservationsPostError>> {
    let uri_str = format!("{}/observations", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns `leaf taxa` associated with observations matching the search criteria and the count of observations they are associated with, ordered by count descending. `Leaf taxa` are the leaves of the taxonomic tree containing only the taxa associated with observations matching the search criteria.
pub async fn observations_species_counts_get(
    configuration: &configuration::Configuration,
    params: ObservationsSpeciesCountsGetParams,
) -> Result<models::SpeciesCountsResponse, Error<ObservationsSpeciesCountsGetError>> {
    let uri_str = format!("{}/observations/species_counts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.acc {
        req_builder = req_builder.query(&[("acc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.captive {
        req_builder = req_builder.query(&[("captive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.endemic {
        req_builder = req_builder.query(&[("endemic", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.geo {
        req_builder = req_builder.query(&[("geo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_please {
        req_builder = req_builder.query(&[("id_please", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identified {
        req_builder = req_builder.query(&[("identified", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.introduced {
        req_builder = req_builder.query(&[("introduced", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.mappable {
        req_builder = req_builder.query(&[("mappable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.native {
        req_builder = req_builder.query(&[("native", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.out_of_range {
        req_builder = req_builder.query(&[("out_of_range", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pcid {
        req_builder = req_builder.query(&[("pcid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photos {
        req_builder = req_builder.query(&[("photos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.popular {
        req_builder = req_builder.query(&[("popular", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sounds {
        req_builder = req_builder.query(&[("sounds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.taxon_is_active {
        req_builder = req_builder.query(&[("taxon_is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.threatened {
        req_builder = req_builder.query(&[("threatened", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.verifiable {
        req_builder = req_builder.query(&[("verifiable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.licensed {
        req_builder = req_builder.query(&[("licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.photo_licensed {
        req_builder = req_builder.query(&[("photo_licensed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.expected_nearby {
        req_builder = req_builder.query(&[("expected_nearby", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.not_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("not_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "not_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ofv_datatype {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("ofv_datatype".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "ofv_datatype",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.photo_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("photo_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "photo_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.place_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("place_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "place_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.project_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("project_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "project_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.rank {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("rank".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "rank",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.site_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("site_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "site_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.sound_license {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("sound_license".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "sound_license",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_taxon_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_taxon_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_taxon_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_name {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.user_login {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_login".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_login",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.ident_user_id {
        req_builder = req_builder.query(&[("ident_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hour {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("hour".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "hour",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_day {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_day".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_day",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_month {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_month".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_month",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.created_year {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("created_year".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "created_year",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.without_term_id {
        req_builder = req_builder.query(&[("without_term_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.without_term_value_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("without_term_value_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "without_term_value_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.term_id_or_unknown {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("term_id_or_unknown".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "term_id_or_unknown",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.annotation_user_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("annotation_user_id".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "annotation_user_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.acc_above {
        req_builder = req_builder.query(&[("acc_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below {
        req_builder = req_builder.query(&[("acc_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.acc_below_or_unknown {
        req_builder = req_builder.query(&[("acc_below_or_unknown", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d1 {
        req_builder = req_builder.query(&[("d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.d2 {
        req_builder = req_builder.query(&[("d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d1 {
        req_builder = req_builder.query(&[("created_d1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_d2 {
        req_builder = req_builder.query(&[("created_d2", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.created_on {
        req_builder = req_builder.query(&[("created_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observed_on {
        req_builder = req_builder.query(&[("observed_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unobserved_by_user_id {
        req_builder = req_builder.query(&[("unobserved_by_user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.apply_project_rules_for {
        req_builder = req_builder.query(&[("apply_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cs {
        req_builder = req_builder.query(&[("cs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csa {
        req_builder = req_builder.query(&[("csa", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.csi {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("csi".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "csi",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.taxon_geoprivacy {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("taxon_geoprivacy".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "taxon_geoprivacy",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.obscuration {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("obscuration".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "obscuration",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.hrank {
        req_builder = req_builder.query(&[("hrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lrank {
        req_builder = req_builder.query(&[("lrank", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.iconic_taxa {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("iconic_taxa".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "iconic_taxa",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.id_above {
        req_builder = req_builder.query(&[("id_above", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.id_below {
        req_builder = req_builder.query(&[("id_below", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.identifications {
        req_builder = req_builder.query(&[("identifications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lat {
        req_builder = req_builder.query(&[("lat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.lng {
        req_builder = req_builder.query(&[("lng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.radius {
        req_builder = req_builder.query(&[("radius", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelat {
        req_builder = req_builder.query(&[("nelat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nelng {
        req_builder = req_builder.query(&[("nelng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlat {
        req_builder = req_builder.query(&[("swlat", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.swlng {
        req_builder = req_builder.query(&[("swlng", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.list_id {
        req_builder = req_builder.query(&[("list_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_in_project {
        req_builder = req_builder.query(&[("not_in_project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.not_matching_project_rules_for {
        req_builder =
            req_builder.query(&[("not_matching_project_rules_for", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observation_accuracy_experiment_id {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| {
                        (
                            "observation_accuracy_experiment_id".to_owned(),
                            p.to_string(),
                        )
                    })
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "observation_accuracy_experiment_id",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_on {
        req_builder = req_builder.query(&[("search_on", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.quality_grade {
        req_builder = req_builder.query(&[("quality_grade", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.updated_since {
        req_builder = req_builder.query(&[("updated_since", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewer_id {
        req_builder = req_builder.query(&[("viewer_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.reviewed {
        req_builder = req_builder.query(&[("reviewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preferred_place_id {
        req_builder = req_builder.query(&[("preferred_place_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ttl {
        req_builder = req_builder.query(&[("ttl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_ancestors {
        req_builder = req_builder.query(&[("include_ancestors", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SpeciesCountsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SpeciesCountsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsSpeciesCountsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Given zero to many of following parameters, returns an array of objects representing new comments and identifications on observations the authenticated user has subscribed to. Requires authentication
pub async fn observations_updates_get(
    configuration: &configuration::Configuration,
    params: ObservationsUpdatesGetParams,
) -> Result<(), Error<ObservationsUpdatesGetError>> {
    let uri_str = format!("{}/observations/updates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.created_after {
        req_builder = req_builder.query(&[("created_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.viewed {
        req_builder = req_builder.query(&[("viewed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.observations_by {
        req_builder = req_builder.query(&[("observations_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObservationsUpdatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Toggles current user's subscription to this observation. If the logged-in user is not subscribed, POSTing here will subscribe them. If they are already subscribed, this will remove the subscription
pub async fn subscriptions_observation_id_subscribe_post(
    configuration: &configuration::Configuration,
    params: SubscriptionsObservationIdSubscribePostParams,
) -> Result<(), Error<SubscriptionsObservationIdSubscribePostError>> {
    let uri_str = format!(
        "{}/subscriptions/observation/{id}/subscribe",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SubscriptionsObservationIdSubscribePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove a vote from an observation
pub async fn votes_unvote_observation_id_delete(
    configuration: &configuration::Configuration,
    params: VotesUnvoteObservationIdDeleteParams,
) -> Result<(), Error<VotesUnvoteObservationIdDeleteError>> {
    let uri_str = format!(
        "{}/votes/unvote/observation/{id}",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VotesUnvoteObservationIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Vote on an observation. A vote with an empty `scope` is recorded as a `fave` of the observation. A vote with scope `needs_id` is recorded as a vote on the Quality Grade criterion \"can the Community ID still be confirmed or improved?\", and can be an up or down vote
pub async fn votes_vote_observation_id_post(
    configuration: &configuration::Configuration,
    params: VotesVoteObservationIdPostParams,
) -> Result<(), Error<VotesVoteObservationIdPostError>> {
    let uri_str = format!(
        "{}/votes/vote/observation/{id}",
        configuration.base_path,
        id = params.id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VotesVoteObservationIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
